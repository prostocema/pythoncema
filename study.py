#NUMBERS

#перевод в двоичное

# a - число
int(a, 2)
bin(a)

#шестнадцатиричное

hex(a)

#STRINGS

#Cтроки можно складывать, умножать. Обращаться по символьно.
#Строки можно обрезать, если не указывать второе число, то срез будет до конца
string1[0:9], string2[10:24]
#Можно otрезать последние несколько символов.
string1[-3:]
#Так же можно указывать шаг среза
a[::2]
#Срезы также можно использовать для получения строки в обратном порядке.
a[::-1]
#Функция len() позволяет получить количество символов в строке.
"""
string1 = 'FastEthernet'

string1.upper()
'FASTETHERNET'

string1.lower()
'fastethernet'

string1.swapcase()
'fASTeTHERNET'

string2 = 'tunnel 0'

string2.capitalize()
'Tunnel 0'
"""

#Метод count() используется для подсчета того, 
#сколько раз символ или подстрока встречаются в строке.

#метод find()
"""
string1 = 'interface FastEthernet0/1'

string1.find('Fast')
10
"""

#method replace()
"""
string1.replace('Fast', 'Gigabit')
'GigabitEthernet0/1'
"""

#метод strip() позволяет избавится от спецсимволов в строке.
#Если необходимо убрать символы только слева или справа lstrip() rstrip() 

# Метод split()
#Метод split() разбивает строку на части, 
#используя как разделитель какой-то символ (или символы) и возвращает список строк.
"""
In [53]: string1 = 'switchport trunk allowed vlan 10,20,30,100-200'

In [54]: commands = string1.split()

In [55]: print(commands)
['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']
"""
# В качестве разделителя можно использовать любой символ.
In [56]: vlans = commands[-1].split(',')

In [57]: print(vlans)
['10', '20', '30', '100-200']
"""
В списке commands последний элемент это строка с вланами, 
поэтому используется индекс -1. 
Затем строка разбивается на части с помощью split commands[-1].split(','). Так как, 
как разделитель указана запятая, получен такой список ['10', '20', '30', '100-200'].
"""
#split() так же удаляет спецсимволы. Ультраполезный метод.
n [60]: sh_ip_int_br = "FastEthernet0/0       15.0.15.1    YES manual up         up"

In [61]: sh_ip_int_br.split()
Out[61]: ['FastEthernet0/0', '15.0.15.1', 'YES', 'manual', 'up', 'up']

#ФОРМАТИРОВАНИЕ СТРОК
In [1]: "interface FastEthernet0/{}".format('1')
Out[1]: 'interface FastEthernet0/1'
Специальный символ {} указывает, 
что сюда подставится значение, которое передается методу format.

Например, таким образом можно вывести данные столбцами 
одинаковой ширины по 15 символов с выравниванием по правой стороне:

In [3]: vlan, mac, intf = ['100', 'aabb.cc80.7000', 'Gi0/1']

In [4]: print("{:>15} {:>15} {:>15}".format(vlan, mac, intf))
            100  aabb.cc80.7000           Gi0/1

Выравнивание по левой стороне:

In [5]: print("{:15} {:15} {:15}".format(vlan, mac, intf))
100             aabb.cc80.7000  Gi0/1

Многострочный вывод:
In [6]: ip_template = '''
   ...: IP address:
   ...: {}
   ...: '''

In [7]: print(ip_template.format('10.1.1.1'))

IP address:
10.1.1.1


С помощью форматирования строк можно конвертировать числа в двоичный формат:

In [11]: '{:b} {:b} {:b} {:b}'.format(192, 100, 1, 1)
Out[11]: '11000000 1100100 1 1'

При этом по-прежнему можно указывать дополнительные параметры, например, ширину столбца:

In [12]: '{:8b} {:8b} {:8b} {:8b}'.format(192, 100, 1, 1)
Out[12]: '11000000  1100100        1        1'

А также можно указать, что надо дополнить числа нулями, вместо пробелов:

In [13]: '{:08b} {:08b} {:08b} {:08b}'.format(192, 100, 1, 1)
Out[13]: '11000000 01100100 00000001 00000001'

Можно указать имена:
In [15]: '{ip}/{mask}'.format(mask=24, ip='10.1.1.1')
Out[15]: '10.1.1.1/24'

Убирает повторение:
In [19]: ip_template = '''
    ...: IP address:
    ...: {:<8} {:<8} {:<8} {:<8}
    ...: {:08b} {:08b} {:08b} {:08b}
    ...: '''

In [20]: print(ip_template.format(192, 100, 1, 1, 192, 100, 1, 1))

IP address:
192      100      1        1
11000000 01100100 00000001 00000001

индексы так же можно указывать

In [21]: ip_template = '''
    ...: IP address:
    ...: {0:<8} {1:<8} {2:<8} {3:<8}
    ...: {0:08b} {1:08b} {2:08b} {3:08b}
    ...: '''

In [22]: print(ip_template.format(192, 100, 1, 1))

IP address:
192      100      1        1
11000000 01100100 00000001 00000001

#Список(List) - упорядоченый тип данных. Можно обращаться поэлементно. Почти строки
Примеры:

list1 = [10,20,30,40]
list2 = ['one', 'cat', "bam"]
list3 = ['qwe', 2, 5, 'qwee']

function list()

list1 = list('router')
print(list1)
['r', 'o', 'u', 't', 'e', 'r']

#Присутствует метод reverse() - разворачивает строку.
#Можно делать списки списков.
#len() - возвращает количество элементов в списке.
#sorted()  - сортирует по возрастанию.

#append() - добавляет элемент.
#extend() - суммирует списки.
#pop() - удаляет указанный элемент по номеру.(по умолчанию удаляет последний)
#remove() - удаляет указанный элемент по содержимому.
#index() - возвращает номер указанного элемента.
#insert(a, b) - позволяет вставить элемент на опр место в списке.
#Где a - позиция, b - содержимое.
#sort() - сортирует.


#Словать(Dictionary) - изменяемый упорядоченный тип данных.
#данные в словаре - это пары ключ: значение.
#доступ к значениям осуществляется по ключу, а не по номеру, как в списках.
#В словаре в качестве значения можно использовать словарь.
#sorted()  - сортирует по возрастанию.
Пример словаря:

london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

Можно записывать и так:

london = {
    'id': 1,
    'name':'London',
    'it_vlan':320,
    'user_vlan':1010,
    'mngmt_vlan':99,
    'to_name': None,
    'to_id': None,
    'port':'G1/0/11'
}

#Полезное:

#clear() - очистка.
#copy() - создает полную копию словаря.Ссылается на тот же объект, что и первый.
#Метод get() запрашивает ключ, и если его нет, вместо ошибки возвращает None.
#Метод get() позволяет также указывать другое значение вместо None. london.get('ios', 'Ooops')
#Метод setdefault() ищет ключ, и если его нет, вместо ошибки создает ключ со значением None.

london.keys()
dict_keys(['name', 'location', 'vendor'])

london.values()
dict_values(['London1', 'London Str', 'Cisco'])

#Удалить ключ и значение del. del london['name']
#Метод update позволяет добавлять в словарь содержимое другого словаря:

Создание с помощью литерала
r1 = {'model': '4451', 'ios': '15.4'}

#dict позволяет создать словарь из строк.
#dict.fromkeys() - создает ключи, оставляя значения пустыми.

#Кортеж(Tuple)

Кортеж - список, который нельзя изменить. Можно только читать.

Создать пустой кортеж:

tuple1 = tuple()
print(tuple1)
()
Кортеж можно сделать из списка(преобразованием), и так же поэлементно обращаться.
Функция sorted() тоже присутствует. 

#SETS

Множества - неизменяемый упорядоченный тип данных. В множестве всегда содержаться только уникальные элементы.

В питоне это элементы разделенные запятыми в фигурных скобках. С помощью множества можно легко убрать повторяющиеся элементы.

vlans = [10, 20, 30, 40, 100, 10]
set(vlans)
{10, 20, 30, 40, 100}

Полезное:

add() - добавляет элемент.
discard() - удаляет элемент, не выдавая ошибку при его отсутствии.
clear() - очищает множество.

Операции:
Объединение:
vlans1 | vlans2
vlans1.union(vlans2)

Пересечение:
vlans1.intersection(vlans2)
vlans1 & vlans2

Создать с помощью литерала пустое множество нельзя, получится словарь.
Можно так:
set2 = set()

Множество из строки:

set('long long long long string')
{' ', 'g', 'i', 'l', 'n', 'o', 'r', 's', 't'}

Множество из списка:

set([10,20,30,10,10,30])
{10, 20, 30} 

#BOOLS

Булевы значения:
истинное значение:
любое ненулевое число
любая непустая строка
любой непустой объект
ложное значение:
0
None
пустая строка
пустой объект

Для проверки булевого значения объекта, можно воспользоваться bool:
items = [1, 2, 3]

In [3]: empty_list = []

In [4]: bool(empty_list)
Out[4]: False

In [5]: bool(items)
Out[5]: True

In [6]: bool(0)
Out[6]: False

In [7]: bool(1)
Out[7]: True

#Преобразования

Преобразование:
int() - строку в int - можно из двоичной в десятичную.
In [2]: int("11111111", 2)
Out[2]: 255

bin() - десятичное в двоичную.
hex() - в шестнадцатиричное.
list() - аргумент в список.
set() - преобразует в множество.
tuple() - преобразует в кортеж.
str() - преобразует в строку.

Проверка типов:

isdigit() - проверка строки только ли в ней цифры.
isalpha() - проверка только ли буквы в строке.
isalnum() - только ли там буквы и цифры.
type() - тип данных.